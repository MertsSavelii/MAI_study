#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Мерц С.П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует 2 основных подхода к NLP: статистический и лингвистичесчкий.

В основе статистического подхода лежит предположение, что содержание текста отражается наиболее часто встречающимися словами. Суть этого анализа заключается в подсчете количества вхождений слов в текст. Главный недостаок такого способа состоит в невозможности учёта связности текста. Таких недостатков лишён лингвистический пожход.

Последний подход основан на лингвистическом анализе, котрый содержит 4 уровня: графематрический(определение параграфов, абзадцов, предложений и т.д.), морфологический(определение морфологических характеристик), синтаксический(определение зависимости слов в предложении), семантический(определение смысла высказывания).

NLP одна из самых распространённых задач, решаемых на языках логического рограммирования. Такие языки и разрабатывались для более простой и естественной реализацией процесса переборов с возвратми и удобства манипулирования символьной информацией.

Пролог, как один из самых популярных логических языков, обладает большими возможностями  по сопоставлению объектов, благодаря чему прекрасно подходит для задачи обработки текстов.

## Задание

7. Реализовать морфологический разбор глаголов: {выучил, изучила, изучили, обучил, ...}. Результат должен содердать сведения о роде и числе.

## Принцип решения

Решал "в лоб". Ищем приставку, окончание, суффикс и остаётся от слова только корень. Род и число получаем из окончания.

Поиск приставки. Сопоставляем первую строку из списка с фактами, в котором есть все (наверное) приставки. Конкатенируем первую строку с последующими с списке. Параллельно с этим находим остаток слова.
```prolog
f_prist([_|[]], prist(""), _):- !.
f_prist([H|Slov], prist(H), Slov):- pristix(H).
f_prist([H, H1|Slov], prist(Prist), Ost_Slova):-
    string_concat(H, H1, NewPrist),
    append([NewPrist], Slov, New_Slov),
    f_prist(New_Slov, prist(Prist), Ost_Slova).
```

Поиск окончания. Сопоставляем первую строку из списка с фактами, в котором есть все (наверное) окончания и заодно род и число. Конкатенируем последнюю строку с предыдущими в списке. Параллельно с этим находим остаток слова.
```prolog
f_end([_|[]], end(""), rod("М"), chislo("ед"), _):-!.
f_end(Slov, end(End), Rod, Chislo, Ost):-
    last(Slov, End),
    del_last(Slov, Ost),
    ending(End, Rod, Chislo).
f_end(Slov, end(E), Rod, Chislo, Ost_Slova):-
    last(Slov, End),
    del_last(Slov, Ost),
    last(Ost, End_2),
    del_last(Ost, Ost_2),
    string_concat(End_2, End, New_End),
    append(Ost_2, [New_End], New_Slov),
    f_end(New_Slov, end(E), Rod, Chislo, Ost_Slova).
```

Поиск суффикса. Алгоритм тот же, что и в поиске окончания.
```prolog
f_suf([_|[]], suf(""), _):-!.
f_suf(Slov, suf(Suffix), Ost):-
    last(Slov, Suffix),
    del_last(Slov, Ost),
    suffix(Suffix).
f_suf(Slov, suf(S), Ost_Slova):-
    last(Slov, Suffix),
    del_last(Slov, Ost),
    last(Ost, Suffix_2),
    del_last(Ost, Ost_2),
    string_concat(Suffix_2, Suffix, New_Suffix),
    append(Ost_2, [New_Suffix], New_Slov),
    f_suf(New_Slov, suf(S), Ost_Slova).
```

## Результаты

```prolog
?- an_morf(["и","з","у","ч","и","л"],X).
X = morf(prist("из"), kor(["у", "ч"]), end("ил"), rod("М"), chislo("ед")).

?- an_morf(["и","з","у","ч","и","л","и"],X).
X = morf(prist("из"), kor(["у", "ч"]), end("или"), rod("НЕТ"), chislo("мн")).

?- an_morf(["п","р","и","у","ч","и","л","и"],X).
X = morf(prist("при"), kor(["у", "ч"]), end("или"), rod("НЕТ"), chislo("мн")).
```

## Выводы

В SWI Prolog нельзя обрабатывать целую строку и приходится работать со списком символов, что тоже весьма удобно. Я использовал предполодение, что найденнеые морфемы единственно возможные. Конечно из-за этого может получчится ошибочный вывод, но реализация проверки я не придумал. Возможно, если написать большущую базу фактов и брать наиболее вероятные варианты, то получится избавится большинства ошибок, но для этого нужно прям очень много строчек кода.

Пролог, конечно мощный инструмент для NLP, в отличии от популярных императивных и функциональных ЯП. Процесс программирования мне напомнил уроки русского языка в школе, конспекты которых я активно использовал во время выполнеия работы. Преподаватели могли добиться больших успехов в программировании на логических ЯП.
