# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Мерц Савелий Павлович
### группа: М80-207Б-20

## Результат проверки

| Преподаватель     | Дата        |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    21.10     |     4         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

Во 2 задании в отчет добавить реализацию предикатов, запросы, результаты.

## Введение

Данные хранятся в виде фактов, так называемых предикатов. Обычно для удобства их выносят в отдельный файл.
Чаще всего работа в prolog сводится к обработке фактов, нахождению ситуаций, при которых те или иные условия становятся верными. Таким образом императивный подход к програмированию применим тут частично, чаще приходится думать, при каких условиях данное выражение будет верным, нежели пытаться в лоб найти все такие ситуации. Можно написать условия при которых утверждение будет верным, а дальше интерпритатор сделает всю работу за вас.

## Задание 1.1: Предикат обработки числового списка

`tail_separ/3` - удаляет хвост начиная с элемента N

Примеры использования:
```prolog
?- tail_separ([1,2,3,4,5],1,L).
L = [].
?- tail_separ([1,2,3,4,5],3,L).
L = [1, 2].
```

Реализация без стандартных:
```prolog
mytail_separ([], _, []).
mytail_separ([H|T], H, []):- !.
mytail_separ([Hl|T], H, [Hl|Tl]):- myTail_separ(T, H, Tl).
```

Каждую итерацию список разделяется на голову и хвост пока список не станет пустым, голова записывается в 3 переменую тем самым собирается ответ.

Реализация со стандартными:
```prolog
tail_separ([], _, []).
tail_separ(L, H, R):-
	append_l(X, Y, L),
	member_l(H, X),
	append_l(R, [H], X),
	!.
```
## Задание 1.2: Предикат обработки числового списка

`mpl/3` - удаляет хвост начиная с элемента N

Примеры использования:
```prolog
?- mympl([1,2,3,4],L).
L = 24.
?- mympl([1],L).
L = 1.
```

Реализация без стандартных:
```prolog
mympl([], 1).
mympl([H|T], X):-
	mympl(T,Xl),
	X is Xl*H.
```

Каждую итерацию спсок разделяется на голову и хвост пока список не станет пустым, голова перемножается результат следующих итераций.

Реализация со стандартными:
```prolog
mpl([], 1).
mpl([H|T], R) :-
	remove_l(H, [H|T], L),
	length_l(BefLen, [H|T]),
	length_l(AfterLen, L),
	mpl(L, DeepR),
	R is DeepR * H * (BefLen - AfterLen),
	!.
```
## Задание 2: Реляционное представление данных

#### Плюсы
 - Читабельность фактов. Чаще всего предикаты именуются по принципу отношения объектов, допустим, grade дает понять что речь идет о оценке студента по предмету, сразу можно понять, что находится внутри.
 - Манипулирование данными на уровне выходной БД и возможность изменения.
#### Минусы
 - Предикаты, которые я реализовал могут работать корректно только на данной реализации предикатов. Любое несоответсвие может привести к неправильной обработке данных или ошибке типизации.
 - Самый медленный доступ к данным.

#### Задание 2/1 возращает среднее значение по оценкам по каждому предмету

Примеры использования:
```prolog
?- h1().
Логическое программирование --- 3.9642857142857144   
Математический анализ --- 3.6785714285714284
Функциональное программирование --- 3.892857142857143
Информатика --- 3.5714285714285716
Английский язык --- 4.178571428571429
Психология --- 3.607142857142857
true.
```

`h1()` - печатает пару "предмет" - "средняя оценка по нему". Использует встроенный предикат findall для поиска всех предметов.

Реализаия:
```prolog
h1() :-
    findall(X, subject(X, _), L),
    h1_out(L).
```

`h1_out(A)` - A - список предметов. Внутри рекурсивно печатает для каждого средний балл. Внутри использет предикат subject для перевода из аббревиатуры в полное название предмета.

Реализаия:
```prolog
h1_out([]).
h1_out([H|T]) :-
    average_grade(H, GRADE),
    subject(H, PRED),
    write(PRED),        tab(1),
    write('---'),       tab(1),
    write(GRADE),       nl,
    h1_out(T).
```

`average_grade(H, GRADE)` - Н - предмет, GRADE - соответствующая ему средняя оценка. Использует встроенный предикат findall для поиска всех оценок по заданному предмету для дальшейшей работы с ними.

Реализаия:
```prolog
average_grade(SUB, X) :-
    findall(PIV, grade(_, SUB, PIV), GRADES),
    length_l(LEN, GRADES),
    sum_l(GRADES, SUM),
    X is SUM / LEN.
```

#### Задание 2/2 возвращает кол во несдавших студентов по каждой группе

Примеры использования:
```prolog
?- h2().
В  101  не сдало  2 человек
В  102  не сдало  4 человек
В  103  не сдало  3 человек
В  104  не сдало  4 человек
true.
```

`h2()` - печатает пару "группа" - "кол-во несдавших учеников". Использует встроенный предикат findall дважды для поиска всех групп и всех учеников.

Реализаия:
```prolog
h2() :-
    findall(X, student(_, X), STUDENTS),    % - список студентов
    findall(Y, student(Y, _), GROUP1),
    rem_repetittions(GROUP1, GROUP2),                   % - группы без повторов
    naive_sort(GROUP2, GROUP), !,           % - группы отсортированы
    h2_out(GROUP, STUDENTS).
```

`rem_repetittions(GROUP1, GROUP2)` - Может оказаться, что кто то из учеников попадет в список дважды или более раз, поэтому необходимо удалить повторения этим предикатом. Возвращает список учеников без повторений.

Реализаия:
```prolog
rem_repetittions([], []) :- !.
rem_repetittions([L],[L]) :- !.
rem_repetittions([H|T], [H|T1]) :-
    remove_l(H, T, T2),
    rem_repetittions(T2, T1), !.
```

`h2_out(GROUP, STUDENTS)` - Получает список групп и студентов и пишет тех, кто не сдал. Для каждой группы проверяется полный список учеников.

Реализаия:
```prolog
h2_out([],_) :- !.
h2_out([H1|T], P) :-
    h2_student_in_group(H1,P,INGROUP),
    h2_num_of_faild_exam(H1, INGROUP, COUNT),
    write('В '),            tab(1),
    write(H1),              tab(1),
    write(' не сдало '),    tab(1),
    write(COUNT),           tab(1),
    write('человек'),       nl,
    h2_out(T, P),!.             % - рекурсиваня проверка след группы
```

`h2_student_in_group(GROUP, STUD, INGROUP)` - Необходимо отсеить тех учеников, которые не находятся в данной группе, возвращает список учеников из полного списка STUD, которые учатся в группе GROUP.

Реализаия:
```prolog
h2_student_in_group(_, [], []) :- !. 
h2_student_in_group(G, [H|T], L) :-
    h2_5(G, H, I),
    h2_student_in_group(G, T, L1),
    append_l(I, L1, L).
```

`h2_num_of_faild_exam(GROUP, INGROUP, COUNT)` - Возвращает кол-во учеников которые не сдали какой то предмет их списка INGROUP, которые учатся в группе GROUP.

Реализаия:
```prolog
h2_num_of_faild_exam(_,[],0).
h2_num_of_faild_exam(G,[H|T],RES) :-        % G - группа [H|T] - массив студентов
    h2_num_of_faild_exam(G, T, R),          % счиатется их кол во рекурсивно от хвоста
    h2_6(H, U),             % проверка на плохую оценку H - текущий студент
    RES is (R + U).
```

`h2_5(G, H, [H])` - Требуется для проверки принадлежности ученика H к группе G, возвращает ученика в формате еденичного списка, иначе пустой список. Внутри использует предикат student для проверки принадлежности к группе.

Реализаия:
```prolog
h2_5(G, H, [H]) :- student(G, H).
h2_5(_, _, []).
```

`h2_6(H, U)` - Нужен для рекурсивного подстчета кол-ва студентов, не сдавших экзамен, принимает студента H, возврщает 1 если не сдал, 0 если сдал. Использует внутри предикат grade.

Реализаия:
```prolog
h2_6(H, 1) :-
    grade(H, _, 2), !.
h2_6(_, 0) :- !.
```

#### Задание 2/3 возвращает кол во несдавших студентов по каждому предмету

Примеры использования:
```prolog
?- h3().
Логическое программирование не сдало 3 человек
Математический анализ не сдало 6 человек
Функциональное программирование не сдало 1 человек
Информатика не сдало 3 человек
Английский язык не сдало 1 человек
Психология не сдало 5 человек
true.
```

`h3()` - Возвращает пару "предмет" - "кол-во несдавших этот предмет студентов". Использует дважды предикат findall для нахождения всех предметов и всех учеников.

Реализаия:
```prolog
h3() :-
    findall(X, student(_, X), STUDENTS),    % - список студентов
    findall(Y, subject(Y, _), SUB),         % - список предметов абрв
    h3_out(SUB, STUDENTS), !.
```

`h3_out(SUB, STUDENTS)` - Рекурсивно проходит по всем предметам печатая кол-во несдавших.  Внутри использет предикат subject для перевода из аббревиатуры в полное название предмета.

Реализаия:
```prolog
h3_out([],_) :- !.
h3_out([H|T], P) :-
    h3_num_of_faild_exam(H, P, COUNT),
    subject(H, H1),
    write(H1),              tab(1),
    write('не сдало'),      tab(1),
    write(COUNT),           tab(1),
    write('человек'),       nl,
    h3_out(T, P).             % - рекурсиваня проверка след группы
```

`h3_num_of_faild_exam(SUB, STUD, RES)` - Считает рекурсивно для предмета SUB по всем ученикам из STUD кол-во несдавших, возвращает RES.

Реализаия:
```prolog

h3_num_of_faild_exam(_,[],0).
h3_num_of_faild_exam(G, [H|T], RES) :-      % G - предмет [H|T] - массив студентов
    h3_num_of_faild_exam(G, T, R),          % счиатется их кол во рекурсивно от хвоста
    h3_bad_grade_chek(H, G, U),          % проверка на плохую оценку H - текущий студент
    RES is (R + U).
```

`h3_bad_grade_chek(STUD, SUB, X)` - Предикат проверки на плохую оценку, если оценка 2, возвращает в X 1, иначе 0. Использует предикат grade.00

Реализаия:
```prolog
h3_bad_grade_chek(H, G, 1) :-
    grade(H, G, 2), !.
h3_bad_grade_chek(_,_,0) :- !.
```

## Выводы

В императивных языках мы указываем как что-либо сделать, в Прологе -- что необходимо сделать. Мы сообщаем системе, что нам известно и задаем вопросы. Программы на Прологе выглядят простыми, но за ними скрывается мощный логический бэкграунд. Язык требовательный, если забыть какой то особый случай и не прописать его, програма ляжет и даже непонятно где, часто приходится сидеть с листом бумаги и ручкой, рисовать рекурсии и включения, можно легко написать неэффективный код, но цель - ужать до минимального кол-ва функций, очень тяжело перестроиться с других языков программирования, таких как С, но очень помогает отладчик.
