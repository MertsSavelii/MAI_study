% Task 1: Предикаты работы со списками

% Проверяет принадлежность элемента списку.
% true если Х принадлежит второму аргументу
% false в обратном
member_l(X, [X|_T]).
member_l(X, [_H|T]) :- member_l(X, T).

% Первый параметр длина списка
% Второй сам список
length_l(0, []).
length_l(X, [_H|T]) :- length_l(X1, T), X is X1 + 1.

% Соединяет в порядке первый список + второй список по порядку
% 3-ий аргумент - полученный список
append_l([],[],[]).
append_l([], X, X).
append_l([X|L1], L2, [X|L3]) :- append_l(L1, L2, L3).

% Удаляет все включения элемента из списка
% Первый аргумент - число которое надо удалить
% Второй аргумент - откуда
% Третий - полученный список
remove_l(_, [], []).
remove_l(E,[E|T],L) :- remove_l(E, T, L).
remove_l(E,[H|T],[H|T1]) :- remove_l(E,T,T1).

% Возвращает все перестановки данного списка
% Первый аргумент список
% Второй - результат перестановки
perm_l([], []).
perm_l([H|T], S) :-
    perm_l(T, P),
    append_l(X, Y, P),
    append_l(X, [H|Y], S).

% Проверяет включение подсписка в список
% Верно если 1-ый содержится в 2-ом
sublist_l([], _).
sublist_l([H|T], [H|L1]) :- sublist_l(T, L1).
sublist_l([H|T], [_|L1]) :- sublist_l([H|T], L1).



% Предикаты обработки списков
% Вариант 17

% Удаляет хвост начиная с элемента N
% Пример: mytail_separ([1,2,3,4],4,[1,2,3]) будет верно

% без стандартных предикатов
mytail_separ([], _, []).
mytail_separ([H|T], H, []):- !.
mytail_separ([Hl|T], H, [Hl|Tl]):- myTail_separ(T, H, Tl).

% со стандартными предикатами
tail_separ([], _, []).
tail_separ(L, H, R):-
	append_l(X, Y, L),
	member_l(H, X),
	append_l(R, [H], X),
	!.


% Предикаты обработки числовых списков
% Вариант 2

% Вычисляет произведение элементов
% Пример: mympl([1,2,3], 6) будет верно

% без стандартных предикатов
mympl([], 1).
mympl([H|T], X):-
	mympl(T,Xl),
	X is Xl*H.

% со стандартными предикатами
mpl([], 1).
mpl([H|T], R) :-
	remove_l(H, [H|T], L),
	length_l(BefLen, [H|T]),
	length_l(AfterLen, L),
	mpl(L, DeepR),
	R is DeepR * H * (BefLen - AfterLen),
	!.
