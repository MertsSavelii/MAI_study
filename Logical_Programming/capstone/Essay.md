# Реферат
## по курсу "Логическое программирование"

### студент: Мерц С.П.

## Задание
4. Как использовать логические языки, чтобы научить компьютер играть в шахматы/шашки 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Вступление

### Что за логические языки?
   
Логические языки - языки программирования в логической парадигме, основанной на автоматическом доказательстве теорем. Процесс программирования в этой парадигме схож с обучением ребёнка. Мы задаём правила и утверждения, на основе которых программа может поверять входные данные на истинность путём сопоставления.

Первым "столпом" логического программирования и по совместительству первым языком ЛП является Planner, в котором совокупность заданных правил обработки данных называлась планом, откуда и название. Язык был разработан для решения проблемы высокого потребления ресурсов через бэктрекинг и спосбности выводить факты без использования стэка. Вторым является Prolog, пожалуй сейчас самый известный и популярный логический язык программирования. Его решили упростить по сравнению с Planner и убрали "план".

От Planner произошли такие языки, как  QA-4, Popler, Conniver и QLISP.
От Prolog Mercury, Visual Prolog, Oz и Fril. 
Так же на базе Planner был разработаны несколько других языков программирования не основанных на бэктрекинге, например Ether.

### Язык логического программирования "Prolog"

Prolog - язык логического программирования, который похож на язык предикатов, представляющий собой подмножество логики предикатов первого порядка, например 
|Название операции |Обозначение в логике предикатов|Обозначение в Prolog|
|------------------|-------------------------------|--------------------|
| и                |  &                            |  ,                 |
| или              |  v                            |  ;                 |
| если             |  =>                           |  :-                |
| не               |  ~                            |  not               |

Программа Prolog отличается от императивных программ привычных большинству и близок к модели Маркова, так как не содержит управляющих конструкций (условных операторов, операторов цикла и т. д.). Она является некоторой моделью какой-то части предметной области. В ней не надо задавать алгоритм как чёткую последовательность действий, необходимо описать некоторую задачу и правила, через утверждения, по которым программа может получить результат.
Основные механизмы в языке: сопоставление с образцом, древовидное представление структур данных и автоматический перебор с возвратами.

Утверждения в Prolog:
Программа является набором правил продукций с предикатами в левой и правой части. Факты - правила без посылки в продукции. Вся система образует своеобразную базу знаний. Запрос является вопросом поставленной задачи, для которого интересна истинность. Если в запросе нет переменных, то ответом будет сухое true/false (Prolog лучше всех знает как выполнять true/false упражнения в английском языке), если же есть, то ищется их интерпретация, при которой запрос был бы истинным.

На сегодня создано достаточно множество реализаций языка Пролог, причём некоторые очень сильно отличаются друг от друга, вот основные: SWI Prolog, Turbo Prolog, Visual Prolog, GNU Prolog и т.д.

Какие задачи можно решать на Prolog? Ну вообще любые. Prlog это полный по Тьюрингу язык программирования, но он не заточен под вычислительные задачи и программировать их на нём не нужно. Зато очень удобно решать задачи со сложными структурами данных. В Prolog очень просто представлять деревья выражений, а список вообще является основной структурой данных, какой является массив в императивных языках. Благодаря этому хорошо решаются задачи с символьными преобразованиями, с обработкой естественного и искусственного языка, искусственного интеллекта, построение экспертных систем или игры с эвристиками (например, шахматы или шашки), о которых далее пойдёт речь.

## Как программа играет в шахматы
  
### Вспомним шахматы

Шахматы - настольная игра, сочетающая в себе элементы искусства, науки и спорта, правила которой сложились к XV веку. Играют обычно два игрока на шестидесяти четырёх клеточной доске.
Правила игры пожалуй опущу, но расскажу о менее известных терминах.

#### Особые ходы:
* Рокировка - если король и одна из ладей не трогались, они могут в один ход поменяться местами (рокироваться). При рокировке король сдвигается на две клетки по направлению к ладье, а ладья ставится на поле между начальной и конечной позицией короля. 

* Взятие на проходе - пешка, проходящая через зону поражения вражеской фигуры, может получить "перо в бок", то есть может быть седина противником, причём фигура противника ставится на битое поле.

#### Шах, мат, пат:
* "Стоять под шахом" значит фигура короля находится на клетке которую можно атаковать.
* Если невозможно королю сойти с битой позиции, то назначается мат и партия объявляется законченной.
* Если невозможно совершить ход, и король стоит не на битом поле, то такая ситуация называется патовой или пат.

#### Этапы партии
* Дебют - стадия начала партии, где-то первые 10—15 ходов. Этот этап характеризуется сложными стратегическими решениями, мобилизацией собственных сил, планирование и начало "сражения". Другими словами завязка.
* Миттельшпиль - средняя часть игры. Именно в ней обычно происходят развитие шахматной партии так, как победа той или иной стороны в первые 15 ходов маловероятена. На доске ещё много фигур, поэтому необходимо активно маневрировать своими силами, устраивать атаки и контратаки. Победа в этой стадии игры вполне вероятная, если один из оппонентов провёл успешную коомбинацию. Или можно переходить в эндшпиль, после взятия большинства фигур.
* Эндшпиль - последняя стадия игры. В кульминации остаётся малое количество действующих фигур. Так как пешка может превратится в любую фигуру её роль в этой стадии резко возрастает. Часто именно это основным игры в эндшпиле становится проведение проходных пешек. Развязкой партии является или победа одной из сторон или ничья.

## Программирования шахмат

### Немного истории развития шахматных программ

Первой машиной для игры в шахматы можно считать, построенную в 1769 венгерским инженером бароном Вольфгангом фон Компеленом, созданную для развлечения королевы Марии-Терезии. Во время демонстрации, изобретатель открывал дверцы шкафа, на котором стояла шахматная доска, где можно было увидеть сложный механизм с множеством узлов. На самом деле внутри сидел сильный шахматист, скрытый от наблюдателей системой зеркал и перегородок.

Ещё одной интересной "человеческой" машиной была "бумажная машина Тьюринга". Этот алгоритм написал Алан Тьюринг в 1951 году. Уникальностью данного алгоритма, являлось то, что в качестве вычислительной машины выступал сам изобретатель. Алану требовалось более получаса, чтобы сделать один ход. Удивительно, но сохранилась одна из партий, где "бумажная машина Тьюринга" проиграла одному из своих коллег создателя.

В 1996 произошло знаменитое и, по моему мнению, неотвратимое событие, впервые программа Deep Blu смогла выиграть партию у чемпиона мира (Гарри Каспарова) в турнирных условиях, но проиграла матч. В 1997 произошёл матч-реванш, искусственный интеллект превзошёл человека и в последующем разрыв только увеличивался.

Можно ещё долго перечислять интересные программы для игры в шахматы. Хорошо рассказал о них Евгений Корнилов в своей книге "Программирование шахмат и других логических игр."

### Основы программирования шахмат

Многие, как и я до начала написания данного эссе, полагают, что компьютер просто хранит огромное множество различных ходов и выбирает подходящий для данной ситуации. На самом же деле уже к 4 ходу, где под 1 ходом подразумевается ход белых и чёрных фигур, а под полу ходом только одной стороны, дерево ходов содержит почти 140 миллионов узлов, что уже тяжело поддаётся анализу в приемлемые временные промежутки.

Современные программы состоят из генератора ходов, оценивающей функции и минимаксную процедуру или её модификацию негамаксную, а так же всевозможные оптимизации. Работа программы проста: генератор генерирует на определённую глубину, оценивающая функция оценивает каждый полученный ход, минимакс находит оптимальную очерёдность ходов, оптимизации оптимизируют полученное дерево с возможным продолжением генерации вглубь.

Генератор проверяет возможность хода и, если ход возможен выводит его. Генератор теоретически получает все возможные ходы и является условно корекурсивным алгоритмом.

Функция оценки позиции на вход получает сгенерированную позицию на доске и оценивает её по всевозможным критериям, чем выше балл - тем больше шансы на выигрыш. Хорошую оценивающую функцию очень тяжело написать ибо необходимо учитывать огромное количество факторов, в настройке которых ей раньше помогал человек, а сейчас гораздо лучшего результата добивается с помощью методов машинного обучения.

Минимакс начиная с листьев дерева, для которых известна их оценка, поднимается на верх выбирая оптимальный для текущего игрока ход. Негомакс меняет знак всех оценок и выбирает путь по максимальным из них.

#### Оптимизации

Главной оптимизацией, которую используют почти все программы, это alpha-beta отсечения, придуманный в 1962 тремя учёными: Алленом Ньюэллом, Гербертом Саймоном и Клиффордом Шоу. В основе этого алгоритма для сокращения числа узлов лежит простая идея, если у меня есть более хороший ход, то можно отсечь заведомо худшие, т.е. если можно установить, что, для определённой ветви значение оценивающей функции в любом случае хуже, чем вычисленное в предыдущем шаге для предыдущей ветви. Благодаря тому, что данный алгоритм не оценивает все варианты, он значительно лучше полного перебора. Суть алгоритма заключается в том, что задаётся две переменные alpha и beta, на каждом этапе игры отслеживались максимальные результаты для игрока и противника. Максимальная оценка хода для игрока - это alpha, ниже которого ход не имеет смысла, beta - максимально хороший ход для противника, хуже которого он не выберет (оценивающая функция выдаст для него минимальную оценку так, как это наиболее плохой ход для игрока). Если при анализе ход получает оценку выше beta — то текущий узел отсекается. Если оценка выше alpha — то alpha обновляется. Благодаря уменьшенному количеству рассматриваемых узлов можно повысить глубину поиска, что даёт приличную прибавку к "силе" программы.

Первые программы очень слабо играли начальный этап партии - дебют. На нём необходимо делать стратегические решения, которые отразятся на все последующие ходы, а из-за сравнительно небольшой глубины поиска и оценивания трудно программе понимать правильный ли ход она сделала в начале. У людей теория дебютов была развито очень хорошо и многократно проанализировалась, были составлены, так называемые, дебютные книги. Благодаря долгому развитию дебютов люди их просто выучили и воспроизводили из памяти, вот и программам можно их вписать в память и выбирать одну из удачных комбинаций с некоторой вероятностью.

В начале говорилось, что простой перебор всех положений слишком трудозатратный процесс. Это правда, однако для ограниченного числа фигур просчитаны все ходы из всех положений. Полученные данные называют эндшпильной таблицей, потому что описывают этап игры, в котором осталось мало фигур - эндшпиль. Они могут занимать огромное количество памяти, но сильно помогли в изучении этого этапа игры. Приведу пару примеров: 

* Таблицы Налимова
Одни из первых, опубликованные ещё в 1998 году. Расчитаны идеальные ходы для 6 фигур при любой начальной позиции. Занимают вес всего-то 1.2 терабайта (это почти вся память моего персонального компьютера).

* Таблицы Ломоносова 
Единственные для семи фигур, распространяются только за деньги. Были получены на суперкомпьютер Ломоносов в МГУ.

## Шахматы на Прологе

Написать подобную игру в шахматы на Prolog не так уж и сложно, если разобраться, стоит только захотеть. Для этого необходимо разбить нашу задачу на несколько блоков.

* Первый - описать с помощью предикатов поведение шахматных фигур, по каким траекториям ходят пешки, слоны кони и остальные, по каким правилам "съедаются" фигуры, а так же особые ходы: рокировка и взятие на подходе.

* Второй - блок начала игры или "СТАРТ", описывающий начальные позиции фигур, задание первого хода и отображение этого хода.

* Третий - блок условий хода, то есть генератор ходов, который будет предлагать с помощью первого блока новые варианты действий, заполняя дерево ходов игры.

* Четвёртый - блок оценивающий правильность хода. Другими словами оценивающая функция. Например, хорошим считается ход, после которого нашему королю не будет поставлен мат. Благодаря этому и третьему блоку, а так же блоку с оптимизациям, программа сможет выбирать правильный ход.

* Пятый - блоки пользователя и компьютера. Блок пользователя - это блок получения входных данных, проверка их на ликвидность, проверки на шах и можно уже отображать на экране смещение фигуры. Блок игры компьютера несколько сложнее. Он конкатенирует в себе вышеописанные блоки. Генерирует ход, оценивает его, выбирает самый выгодный вариант, проверяет на ликвидность и уже воспроизводит его.

* Дополнительный блок в котором всякие вспомогательные предикаты на подобии предиката выбора сторон или вывода доски с фигурами в терминал пользователя.

Это простейшее описание весьма слабой и глупой программы. Глупой от того, что выбирается любой ход, который не приводит к мату. Чтобы сделать игру интереснее можно добавить всевозможных хитрых оптимизаций или книг дебюта с таблицами эндшпиля.

## Вывод

Подводя итог можно сказать, что мы познакомились с парадигмой логического программирования, в частности с языком Prolog. Узнали его уникальные особенности, для чего и где применяется. Познакомились с теорией шахматных программ и описали алгоритм написания примитивной игры пользователя с компьютером в шахматы на языке Prolog, и выяснили какие есть недочеты у этого алгоритма и как можно было бы его улучшить.

 ## Список литературы

1. Интернет источник - википедия
2. Сошников Д.В. - "Парадигма логического программирования."
3. Корнилов Е.Н. "Программирование шахмат и других логических игр."
4. Петер Флах - "Машинное обучение. Наука и искусство построения алгоритмов, которые извлекают знания из данных."
5.  Интернет источник - ИНТУИТ